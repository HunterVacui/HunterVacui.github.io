<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Preference Graph Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            color: white;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .controls {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            margin-right: 20px;
        }

        .file-input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-label {
            display: inline-block;
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            font-weight: 600;
        }

        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.3);
        }

        .legend {
            display: flex;
            align-items: center;
            gap: 30px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .legend-line {
            width: 40px;
            height: 4px;
            border-radius: 2px;
        }

        .graph-container {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
            position: relative;
        }

        #graph {
            width: 100%;
            height: 70vh;
            min-height: 500px;
        }

        .info-panel {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
        }

        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .node:hover {
            stroke-width: 4px;
        }

        .node-label {
            text-anchor: middle;
            dominant-baseline: middle;
            font-size: 12px;
            font-weight: 600;
            pointer-events: none;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
        }

        .link {
            stroke-width: 3;
            opacity: 0.8;
            transition: opacity 0.3s ease;
        }

        .link:hover {
            opacity: 1;
            stroke-width: 5;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px;
            border-radius: 8px;
            pointer-events: none;
            font-size: 12px;
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.7);
        }

        .footer p {
            margin: 5px 0;
        }

        .sample-button {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-left: 10px;
        }

        .sample-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(78, 205, 196, 0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ Preference Graph Visualizer</h1>
            <p>Explore AI preferences through interactive network visualization</p>
        </div>

        <div class="controls">
            <div class="file-input-wrapper">
                <input type="file" id="fileInput" class="file-input" accept=".dot,.json">
                <label for="fileInput" class="file-input-label">üìÅ Load Preference Data</label>
            </div>
            <button class="sample-button" onclick="loadSampleData()">üçï Load Pizza Sample</button>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-line" style="background: linear-gradient(to right, #c90011, #0eff66);"></div>
                    <span>Strong Preference (Red ‚Üí Green)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line" style="background: linear-gradient(to right, #727272, #0eff67);"></div>
                    <span>Weak Preference (Gray ‚Üí Green)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line" style="background: #747d8c;"></div>
                    <span>No Preference (Gray, Hidden by Default)</span>
                </div>
            </div>
        </div>

        <div class="graph-container">
            <svg id="graph"></svg>
            <div class="info-panel">
                <p id="graphInfo">Load preference data to see the visualization</p>
            </div>
        </div>

        <div class="footer">
            <p>Vibecoded with AI</p>
            <p>Copyright ¬© 2025 vacui.dev, all rights reserved</p>
        </div>
    </div>

    <div class="tooltip" id="tooltip" style="display: none;"></div>

    <script>
        const svg = d3.select("#graph");
        const tooltip = d3.select("#tooltip");
        let simulation;

        // Sample data from your pizza poll
        const sampleData = {
            "nodes": [
                {"key": "0", "edges": [{"to_key": "1", "score": 0.5}, {"to_key": "2", "score": 0.9993164871097749}, {"to_key": "3", "score": 0.5}, {"to_key": "4", "score": 0.5}, {"to_key": "5", "score": 0.5}, {"to_key": "6", "score": 0.5}]},
                {"key": "1", "edges": [{"to_key": "0", "score": 0.5}, {"to_key": "2", "score": 1}, {"to_key": "3", "score": 0.5}, {"to_key": "4", "score": 0.5}, {"to_key": "5", "score": 0.5}, {"to_key": "6", "score": 0.0009633674836833858}]},
                {"key": "2", "edges": [{"to_key": "0", "score": 0.0006835128902250576}, {"to_key": "1", "score": 0.0}, {"to_key": "3", "score": 0}, {"to_key": "4", "score": 0}, {"to_key": "5", "score": 0.1344707261376624}, {"to_key": "6", "score": 0}]},
                {"key": "3", "edges": [{"to_key": "0", "score": 0.5}, {"to_key": "1", "score": 0.5}, {"to_key": "2", "score": 1.0}, {"to_key": "4", "score": 0.5}, {"to_key": "5", "score": 0.769491601444906}, {"to_key": "6", "score": 0.5}]},
                {"key": "4", "edges": [{"to_key": "0", "score": 0.5}, {"to_key": "1", "score": 0.5}, {"to_key": "2", "score": 1.0}, {"to_key": "3", "score": 0.5}, {"to_key": "5", "score": 0.769491601444906}, {"to_key": "6", "score": 0.5}]},
                {"key": "5", "edges": [{"to_key": "0", "score": 0.5}, {"to_key": "1", "score": 0.5}, {"to_key": "2", "score": 0.8655292738623376}, {"to_key": "3", "score": 0.23050839855509397}, {"to_key": "4", "score": 0.23050839855509397}, {"to_key": "6", "score": 0.5}]},
                {"key": "6", "edges": [{"to_key": "0", "score": 0.5}, {"to_key": "1", "score": 0.9990366325163166}, {"to_key": "2", "score": 1.0}, {"to_key": "3", "score": 0.5}, {"to_key": "4", "score": 0.5}, {"to_key": "5", "score": 0.5}]}
            ]
        };

        const pizzaLabels = {
            "0": "cheese",
            "1": "pineapple", 
            "2": "fish",
            "3": "bacon",
            "4": "sausage",
            "5": "chorizo",
            "6": "pepperoni"
        };

        function getPreferenceColor(score) {
            if (Math.abs(score - 0.5) < 0.02) return "#747d8c"; // Gray for neutral
            
            // Create gradient from red (strong against) to green (strong for)
            if (score < 0.5) {
                // Red to orange (0 to 0.5)
                const t = score * 2; // 0 to 1
                return d3.interpolateRgb("#c90011", "#0eff66")(t);
            } else {
                // Gray to green (0.5 to 1)
                const t = (score - 0.5) * 2; // 0 to 1
                return d3.interpolateRgb("#727272", "#0eff67")(t);
            }
        }

        function processPreferenceData(data, labels = null) {
            const nodes = data.nodes.map(node => ({
                id: node.key,
                label: labels && labels[node.key] ? labels[node.key] : node.key,
                edges: node.edges
            }));

            const links = [];
            const processedPairs = new Set();

            // Create links, avoiding duplicates
            nodes.forEach(node => {
                node.edges.forEach(edge => {
                    const pairKey = [node.id, edge.to_key].sort().join('-');
                    
                    if (!processedPairs.has(pairKey)) {
                        processedPairs.add(pairKey);
                        
                        // Find the reverse edge
                        const targetNode = nodes.find(n => n.id === edge.to_key);
                        const reverseEdge = targetNode ? targetNode.edges.find(e => e.to_key === node.id) : null;
                        
                        if (reverseEdge) {
                            // Determine which side has stronger preference
                            const preferenceStrength = Math.abs(edge.score - 0.5);
                            const reversePreferenceStrength = Math.abs(reverseEdge.score - 0.5);
                            
                            // Only show links with meaningful preferences (not neutral 0.5)
                            if (preferenceStrength > 0.02 || reversePreferenceStrength > 0.02) {
                                links.push({
                                    source: node.id,
                                    target: edge.to_key,
                                    sourceScore: edge.score,
                                    targetScore: reverseEdge.score,
                                    strength: Math.max(preferenceStrength, reversePreferenceStrength)
                                });
                            }
                        }
                    }
                });
            });

            return { nodes, links };
        }

        function renderGraph(data, labels = null) {
            const { nodes, links } = processPreferenceData(data, labels);
            
            // Clear previous graph
            svg.selectAll("*").remove();
            
            const width = svg.node().getBoundingClientRect().width;
            const height = svg.node().getBoundingClientRect().height;
            
            svg.attr("viewBox", [0, 0, width, height]);

            // Create force simulation
            simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(200))
                .force("charge", d3.forceManyBody().strength(-50))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collision", d3.forceCollide().radius(40));

            // Create gradient definitions for links
            const defs = svg.append("defs");
            
            links.forEach((link, i) => {
                const gradient = defs.append("linearGradient")
                    .attr("id", `gradient-${i}`)
                    .attr("gradientUnits", "userSpaceOnUse");
                
                gradient.append("stop")
                    .attr("offset", "0%")
                    .attr("stop-color", getPreferenceColor(link.sourceScore));
                
                gradient.append("stop")
                    .attr("offset", "100%")
                    .attr("stop-color", getPreferenceColor(link.targetScore));
            });

            // Create links
            const link = svg.append("g")
                .selectAll("line")
                .data(links)
                .enter()
                .append("line")
                .attr("class", "link")
                .attr("stroke", (d, i) => `url(#gradient-${i})`)
                .attr("stroke-width", d => 2 + d.strength * 6)
                .on("mouseover", function(event, d) {
                    const sourceNode = nodes.find(n => n.id === d.source.id);
                    const targetNode = nodes.find(n => n.id === d.target.id);
                    
                    tooltip.style("display", "block")
                        .html(`
                            <strong>${sourceNode.label} ‚Üí ${targetNode.label}</strong><br/>
                            Preference: ${(d.sourceScore * 100).toFixed(1)}%<br/>
                            <strong>${targetNode.label} ‚Üí ${sourceNode.label}</strong><br/>
                            Preference: ${(d.targetScore * 100).toFixed(1)}%
                        `)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", function() {
                    tooltip.style("display", "none");
                });

            // Create nodes
            const node = svg.append("g")
                .selectAll("circle")
                .data(nodes)
                .enter()
                .append("circle")
                .attr("class", "node")
                .attr("r", 25)
                .attr("fill", "#4ecdc4")
                .attr("stroke", "#ffffff")
                .attr("stroke-width", 3)
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            // Create node labels
            const labels_g = svg.append("g")
                .selectAll("text")
                .data(nodes)
                .enter()
                .append("text")
                .attr("class", "node-label")
                .attr("fill", "white")
                .text(d => d.label.length > 12 ? d.label.substring(0, 12) + "..." : d.label);

            // Update positions on tick
            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                // Update gradient positions
                links.forEach((d, i) => {
                    defs.select(`#gradient-${i}`)
                        .attr("x1", d.source.x)
                        .attr("y1", d.source.y)
                        .attr("x2", d.target.x)
                        .attr("y2", d.target.y);
                });

                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);

                labels_g
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
            });

            // Update info panel
            document.getElementById("graphInfo").textContent = 
                `Showing ${nodes.length} options with ${links.length} preference relationships`;

            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        function loadSampleData() {
            renderGraph(sampleData, pizzaLabels);
        }

        function parseDataFromText(text) {
            try {
                // Try JSON first
                return JSON.parse(text);
            } catch (e) {
                // Try to extract JSON from DOT file
                const rawDataMatch = text.match(/=====================RAW DATA==========([\s\S]*?)$/);
                if (rawDataMatch) {
                    const jsonText = rawDataMatch[1].trim().replace(/'/g, '"');
                    return JSON.parse(jsonText);
                }
                throw new Error("Could not parse data format");
            }
        }

        // File input handler
        document.getElementById("fileInput").addEventListener("change", function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = parseDataFromText(e.target.result);
                    renderGraph(data);
                } catch (error) {
                    alert("Error loading file: " + error.message);
                }
            };
            reader.readAsText(file);
        });

        // Handle window resize
        window.addEventListener("resize", () => {
            if (simulation) {
                const width = svg.node().getBoundingClientRect().width;
                const height = svg.node().getBoundingClientRect().height;
                svg.attr("viewBox", [0, 0, width, height]);
                simulation.force("center", d3.forceCenter(width / 2, height / 2));
                simulation.alpha(0.3).restart();
            }
        });

        // Load sample data on page load
        loadSampleData();
    </script>
</body>
</html>